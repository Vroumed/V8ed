using Swashbuckle.AspNetCore.SwaggerGen;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using Vroumed.V8ed.Controllers.Attributes;
using Vroumed.V8ed.Dependencies;
using Vroumed.V8ed.Dependencies.Attributes;
using Vroumed.V8ed.Extensions;
using Vroumed.V8ed.Managers;

namespace Vroumed.V8ed.Controllers;

public abstract class Crud : IDependencyCandidate
{
  [Resolved]
  private DatabaseManager DatabaseManager { get; set; } = null!;

  [Resolved]
  private DependencyInjector DependencyInjector { get; set; } = null!;

  [ResolvedLoader]
  private void Load()
  {
    PropertyInfo[] properties = GetType().GetProperties(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
    bool doInit = false;
    (PropertyInfo prop, CrudColumn pk)? initBy = null;

    List<(PropertyInfo, CrudColumn)> columns = new();
    foreach (PropertyInfo property in properties)
      if (property.GetCustomAttributes().FirstOrDefault(c => c is CrudColumn) is CrudColumn column)
      {
        columns.Add((property, column));
        if (column.PrimaryKey && property.GetValue(this) != default)
        {
          doInit = true;
          initBy = (property, column);
        }
      }

    List<(PropertyInfo prop, CrudEnumerableWhere clause)> autoGeneratedColumns = new();

    foreach (PropertyInfo property in properties)
      if (property.GetCustomAttributes().FirstOrDefault(c => c is CrudEnumerableWhere) is CrudEnumerableWhere clause)
        autoGeneratedColumns.Add((property, clause));

    if (!doInit)
      return;

    CrudTable table = GetType().GetCustomAttributes().FirstOrDefault(a => a is CrudTable) as CrudTable
        ?? throw new InvalidOperationException($"Type {GetType().Name} does not have the required attribute {nameof(CrudTable)}");

    string tableName = table.Name;

    Task.Run(async () =>
    {
      Dictionary<string, object>? data = await DatabaseManager.FetchOne($"SELECT * FROM {tableName} WHERE {initBy!.Value.pk.Name} = @prop",
        new Dictionary<string, object>()
        {
          ["prop"] = initBy!.Value.prop.GetValue(this)!
        });

      if (data == null)
        return;

      foreach ((PropertyInfo prop, CrudColumn col) in columns)
        if (prop.PropertyType.IsAssignableTo(typeof(Crud)))
        {
          Type type = prop.PropertyType;

          if (Activator.CreateInstance(type) is not Crud child)
            throw new InvalidOperationException(
              $"Type {type.Name} linked from {prop.Name} ({col.Name}) is not a Valid Foreign Key");

          PropertyInfo pk = type.GetPrimaryKey();

          pk.SetValue(child, data[col.Name]);

          DependencyInjector.Resolve(child);

          prop.SetValue(this, child);
        }
        else
          prop.SetValue(this, data[col.Name]);

      foreach ((PropertyInfo prop, CrudEnumerableWhere clause) in autoGeneratedColumns)
      {
        Type genericType = prop.PropertyType.GetGenericArguments()[0];

        string foreignTable = genericType.GetTableName();

        PropertyInfo pkProp = genericType.GetPrimaryKey();

        if (!genericType.IsAssignableTo(typeof(Crud)))
          throw new InvalidOperationException($"type {genericType.Name} is not a {nameof(Crud)}");

        if (pkProp == null)
          throw new InvalidOperationException($"type {genericType.Name} has no primary key");

        string pk = genericType.GetColumns().First(s => s.prop == pkProp).column.Name;

        string query = $"SELECT {pk} FROM {foreignTable} WHERE {clause.ColumnExtern} = @value";
        Dictionary<string, object> parameters = new()
        {
          ["value"] = data[clause.ColumnLocal]
        };

        List<Dictionary<string, object>> result = await DatabaseManager.FetchAll(query, parameters);

        Type listType = typeof(List<>).MakeGenericType(genericType);
        object? listInstance = Activator.CreateInstance(listType);

        MethodInfo? addMethod = listType.GetMethod("Add");

        foreach (Dictionary<string, object> dictionary in result)
        {
          if (Activator.CreateInstance(genericType) is not Crud child)
            throw new InvalidOperationException(
              $"Type {genericType.Name} linked from {prop.Name} is not a Valid Foreign Key");

          pkProp.SetValue(child, dictionary[pk]);

          DependencyInjector.Resolve(child);

          addMethod?.Invoke(listInstance, new[] { child });
        }

        prop.SetValue(this, listInstance);

      }
    }).Wait();
  }

  public async Task Insert()
  {
    CrudTable table = GetType().GetCustomAttributes().FirstOrDefault(a => a is CrudTable) as CrudTable
                      ?? throw new InvalidOperationException($"Type {GetType().Name} does not have the required attribute {nameof(CrudTable)}");

    string tableName = table.Name;
    List<(PropertyInfo prop, CrudColumn column)> columns = this.GetColumns();
    (PropertyInfo prop, CrudColumn column) autoIncrementColumn = columns.FirstOrDefault(c => c.column.IsAutoIncrement);

    if (autoIncrementColumn.prop != null && !autoIncrementColumn.prop.GetValue(this).Equals(autoIncrementColumn.prop.PropertyType.GetDefaultValue()))
      throw new InvalidOperationException($"Column {autoIncrementColumn.column.Name} is auto-increment and its value must be null before insert.");

    string columnNames = string.Join(", ", columns.Where(c => !c.column.IsAutoIncrement).Select(c => c.column.Name));
    string paramNames = string.Join(", ", columns.Where(c => !c.column.IsAutoIncrement).Select(c => "@" + c.column.Name));

    string query = $"INSERT INTO {tableName} ({columnNames}) VALUES ({paramNames})";

    Dictionary<string, object?> parameters = columns.Where(c => !c.column.IsAutoIncrement).ToDictionary(c => c.column.Name, c =>
    {
      if (!c.prop.PropertyType.IsAssignableTo(typeof(Crud)))
        return c.prop.GetValue(this)!;

      if (c.prop.GetValue(this) is not Crud obj)
        return null;

      obj.Insert().Wait();
      return c.prop.PropertyType.GetPrimaryKey().GetValue(obj);
    });

    await DatabaseManager.Execute(query, parameters);

    // Retrieve the auto-incremented ID
    if (autoIncrementColumn.prop != null)
    {
      string lastInsertIdQuery = $"""
                SELECT (auto_increment-1) AS lastId
        FROM information_schema.tables
        WHERE table_name = '{tableName}'
        AND table_schema = '{DatabaseManager.Database}'
        """;
      Dictionary<string, object>? lastInsertId = await DatabaseManager.FetchOne(lastInsertIdQuery, null);
      autoIncrementColumn.prop.SetValue(this, Convert.ChangeType(lastInsertId["lastId"], autoIncrementColumn.prop.PropertyType));
    }

    await SaveEnumerables();
  }

  private async Task SaveEnumerables(bool deleteOnly = false)
  {
    PropertyInfo[] properties = GetType()
      .GetProperties(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance)
      .Where(s => s
        .GetCustomAttributes<CrudEnumerableWhere>().Any() && s.PropertyType.GetInterfaces().Contains(typeof(IEnumerable))).ToArray();

    foreach (PropertyInfo property in properties)
    {
      CrudEnumerableWhere ens = property.GetCustomAttribute<CrudEnumerableWhere>()!;

      Type targetType = property.PropertyType.GetGenericArguments()[0];

      string tableName = targetType.GetTableName();

      string delete = $"DELETE FROM {tableName} WHERE  {ens.ColumnExtern} {ens.ComparisonType.ToSqlOperator()} @value";

      Dictionary<string, object?> parameters = new()
      {
        {"value", this.GetColumns().First(s => s.column.Name == ens.ColumnLocal).prop.GetValue(this)}
      };

      DatabaseManager.Execute(delete, parameters);

      if (deleteOnly)
        continue;

      if (property.GetValue(this) is not IEnumerable enumerable)
        continue;
      foreach (object o in enumerable)
        if (o is Crud crudItem)
          await crudItem.Insert();
    }
  }

  public async Task Update()
  {
    CrudTable table = GetType().GetCustomAttributes().FirstOrDefault(a => a is CrudTable) as CrudTable
                      ?? throw new InvalidOperationException($"Type {GetType().Name} does not have the required attribute {nameof(CrudTable)}");

    string tableName = table.Name;
    List<(PropertyInfo prop, CrudColumn column)> columns = this.GetColumns();
    (PropertyInfo prop, CrudColumn pk)? pkc = columns.FirstOrDefault(c => c.column.PrimaryKey);
    if (pkc == null)
      throw new InvalidOperationException($"Type {GetType().Name} does not have a primary key column.");

    (PropertyInfo prop, CrudColumn pk) primaryKeyColumn = pkc.Value;

    // Building the SET part of the query
    string setClause = string.Join(", ", columns.Where(c => !c.column.PrimaryKey).Select(c => $"{c.column.Name} = @{c.column.Name}"));

    string query = $"UPDATE {tableName} SET {setClause} WHERE {primaryKeyColumn.pk.Name} = @{primaryKeyColumn.pk.Name}";

    Dictionary<string, object?> parameters = columns.ToDictionary(c => c.column.Name, c =>
    {
      if (!c.prop.PropertyType.IsAssignableTo(typeof(Crud)))
        return c.prop.GetValue(this)!;

      if (c.prop.GetValue(this) is not Crud obj)
        return null;

      obj.Update();
      return c.prop.PropertyType.GetPrimaryKey().GetValue(obj);

    });

    await DatabaseManager.Execute(query, parameters);

    await SaveEnumerables();
  }

  public async Task Delete()
  {
    CrudTable table = GetType().GetCustomAttributes().FirstOrDefault(a => a is CrudTable) as CrudTable
                      ?? throw new InvalidOperationException($"Type {GetType().Name} does not have the required attribute {nameof(CrudTable)}");

    string tableName = table.Name;
    List<(PropertyInfo prop, CrudColumn column)> columns = this.GetColumns();
    (PropertyInfo prop, CrudColumn pk)? pkc = columns.FirstOrDefault(c => c.column.PrimaryKey);

    if (pkc == null)
      throw new InvalidOperationException($"Type {GetType().Name} does not have a primary key column.");

    (PropertyInfo prop, CrudColumn pk) primaryKeyColumn = pkc.Value;

    string query = $"DELETE FROM {tableName} WHERE {primaryKeyColumn.pk.Name} = @{primaryKeyColumn.pk.Name}";

    Dictionary<string, object?> parameters = new()
    {
      [primaryKeyColumn.pk.Name] = primaryKeyColumn.prop.GetValue(this)
    };

    await DatabaseManager.Execute(query, parameters);

    await SaveEnumerables(true);
  }
}